<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tinytroupe.extraction.results_reporter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tinytroupe.extraction.results_reporter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import json
from typing import Union, List, Dict, Any
from rich.console import Console
from rich.markdown import Markdown

from tinytroupe.extraction import logger
from tinytroupe.agent import TinyPerson
from tinytroupe.environment import TinyWorld
from tinytroupe.utils import LLMChat
from tinytroupe import default


class ResultsReporter:
    
    def __init__(self, 
                 default_reporting_task: str = &#34;Summarize the key findings, insights, and outcomes from the simulation data.&#34;,
                 verbose: bool = False):
        &#34;&#34;&#34;
        Initializes the ResultsReporter.
        
        Args:
            default_reporting_task (str): The default task to ask agents when generating reports.
            verbose (bool): Whether to print debug messages.
        &#34;&#34;&#34;
        self.default_reporting_task = default_reporting_task
        self.verbose = verbose
        self.console = Console()
        
        # Cache for generated reports
        self.last_report = None
    
    def report_from_agents(self,
                          agents: Union[TinyPerson, TinyWorld, List[TinyPerson]],
                          reporting_task: str = None,
                          report_title: str = &#34;Simulation Report&#34;,
                          include_agent_summaries: bool = True,
                          consolidate_responses: bool = True,
                          requirements: str = &#34;Present the findings in a clear, structured manner.&#34;) -&gt; str:
        &#34;&#34;&#34;
        Option 1: Generate a report by asking agents about specific reporting tasks.
        
        Args:
            agents: Single agent, TinyWorld, or list of agents to interview.
            reporting_task: The specific task to ask agents about.
            report_title: Title for the generated report.
            include_agent_summaries: Whether to include agent mini-bios in the report.
            consolidate_responses: Whether to consolidate all responses into a single report.
            requirements: Formatting or content requirements for the report.
            
        Returns:
            str: The generated Markdown report.
        &#34;&#34;&#34;
        if reporting_task is None:
            reporting_task = self.default_reporting_task
            
        # Extract agents from input
        agent_list = self._extract_agents(agents)
        
        if self.verbose:
            logger.info(f&#34;Interviewing {len(agent_list)} agents for report generation.&#34;)
        
        # Collect responses from agents
        agent_responses = []
        for agent in agent_list:
            response = self._interview_agent(agent, reporting_task)
            agent_responses.append({
                &#34;agent&#34;: agent,
                &#34;response&#34;: response
            })
        
        # Generate the report
        report = self._format_agent_interview_report(
            agent_responses, 
            report_title, 
            reporting_task,
            include_agent_summaries,
            consolidate_responses,
            requirements
        )
        
        self.last_report = report
        return report
    
    def report_from_interactions(self,
                                agents: Union[TinyPerson, TinyWorld, List[TinyPerson]],
                                report_title: str = &#34;Interaction Analysis Report&#34;,
                                include_agent_summaries: bool = True,
                                first_n: int = None,
                                last_n: int = None,
                                max_content_length: int = None,
                                requirements: str = &#34;Present the findings in a clear, structured manner.&#34;) -&gt; str:
        &#34;&#34;&#34;
        Option 2: Generate a report by analyzing agents&#39; historical interactions.
        
        Args:
            agents: Single agent, TinyWorld, or list of agents to analyze.
            report_title: Title for the generated report.
            include_agent_summaries: Whether to include agent mini-bios.
            first_n: Number of first interactions to include.
            last_n: Number of last interactions to include.
            max_content_length: Maximum content length for interactions.
            requirements: Formatting or content requirements for the report.
            
        Returns:
            str: The generated Markdown report.
        &#34;&#34;&#34;
        # Extract agents from input
        agent_list = self._extract_agents(agents)
        
        if self.verbose:
            logger.info(f&#34;Analyzing interactions from {len(agent_list)} agents.&#34;)
        
        # Collect interaction data
        interactions_data = []
        for agent in agent_list:
            interactions = agent.pretty_current_interactions(
                simplified=True,
                first_n=first_n,
                last_n=last_n,
                max_content_length=max_content_length
            )
            interactions_data.append({
                &#34;agent&#34;: agent,
                &#34;interactions&#34;: interactions
            })
        
        # Generate the report
        report = self._format_interactions_report(
            interactions_data,
            report_title,
            include_agent_summaries,
            requirements
        )
        
        self.last_report = report
        return report
    
    def report_from_data(self,
                        data: Union[str, Dict[str, Any], List[Dict[str, Any]]],
                        report_title: str = &#34;Data Report&#34;,
                        requirements: str = &#34;Present the findings in a clear, structured manner.&#34;) -&gt; str:
        &#34;&#34;&#34;
        Option 3: Generate a report from raw text or structured data.
        
        Args:
            data: Raw text, dictionary, or list of dictionaries to format.
            report_title: Title for the generated report.
            requirements: Formatting or content requirements for the report. If None, uses simple formatting.
            
        Returns:
            str: The generated Markdown report.
        &#34;&#34;&#34;
        if self.verbose:
            logger.info(&#34;Generating report from raw data.&#34;)
        
        # Generate the report
        report = self._format_data_report(data, report_title, requirements)
        
        self.last_report = report
        return report
    
    def display_report(self, report: str = None):
        &#34;&#34;&#34;
        Display a report on the console with rich formatting.
        
        Args:
            report: The report to display. If None, uses the last generated report.
        &#34;&#34;&#34;
        if report is None:
            report = self.last_report
            
        if report is None:
            self.console.print(&#34;[red]No report available to display.[/red]&#34;)
            return
            
        markdown = Markdown(report)
        self.console.print(markdown)
    
    def save_report(self, 
                   filename: str,
                   report: str = None,
                   verbose: bool = None):
        &#34;&#34;&#34;
        Save a report to a file.
        
        Args:
            filename: The filename to save the report to.
            report: The report to save. If None, uses the last generated report.
            verbose: Whether to print confirmation message.
        &#34;&#34;&#34;
        if report is None:
            report = self.last_report
            
        if report is None:
            raise ValueError(&#34;No report available to save.&#34;)
            
        if verbose is None:
            verbose = self.verbose
            
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            f.write(report)
            
        if verbose:
            logger.info(f&#34;Report saved to {filename}&#34;)
    
    def _extract_agents(self, agents) -&gt; List[TinyPerson]:
        &#34;&#34;&#34;Extract a list of TinyPerson objects from various input types.&#34;&#34;&#34;
        if isinstance(agents, TinyPerson):
            return [agents]
        elif isinstance(agents, TinyWorld):
            return agents.agents
        elif isinstance(agents, list):
            return agents
        else:
            raise ValueError(&#34;Agents must be a TinyPerson, TinyWorld, or list of TinyPerson objects.&#34;)
    
    def _interview_agent(self, agent: TinyPerson, reporting_task: str) -&gt; str:
        &#34;&#34;&#34;Interview a single agent about the reporting task.&#34;&#34;&#34;
        if self.verbose:
            logger.debug(f&#34;Interviewing agent {agent.name} about: {reporting_task}&#34;)
        
        # Following TinyTroupe patterns - directly interact with the agent
        prompt = f&#34;&#34;&#34;
        I need you to provide a comprehensive report based on your experiences and observations.
        
        Reporting task: {reporting_task}
        
        Please provide detailed insights, specific examples, and key findings from your perspective.
        Focus on what you&#39;ve learned, observed, and experienced during the simulation.
        &#34;&#34;&#34;
        
        # Use listen_and_act pattern to get agent&#39;s response
        agent.listen(prompt)
        actions = agent.act(return_actions=True)
        
        # Extract the response from the agent&#39;s actions
        response = &#34;&#34;
        for action in actions:
            if action[&#34;action&#34;][&#34;type&#34;] == &#34;TALK&#34;:
                response += action[&#34;action&#34;][&#34;content&#34;] + &#34;\n&#34;
        
        if self.verbose:
            logger.debug(f&#34;Agent {agent.name} response received.&#34;)
        
        return response.strip()
    
    def _format_agent_interview_report(self, 
                                     agent_responses: List[Dict],
                                     title: str,
                                     task: str,
                                     include_summaries: bool,
                                     consolidate: bool,
                                     requirements: str) -&gt; str:
        &#34;&#34;&#34;Format agent interview responses into a Markdown report.&#34;&#34;&#34;
        # Prepare data for LLM formatting
        agents_data = []
        for resp in agent_responses:
            agent_info = {
                &#34;name&#34;: resp[&#34;agent&#34;].name,
                &#34;response&#34;: resp[&#34;response&#34;]
            }
            if include_summaries:
                agent_info[&#34;bio&#34;] = resp[&#34;agent&#34;].minibio(extended=False)
            agents_data.append(agent_info)
        
        # Generate report using LLM
        return self._generate_report_with_llm(
            title=title,
            report_type=&#34;agent_interview&#34;,
            data={
                &#34;reporting_task&#34;: task,
                &#34;agents_data&#34;: agents_data,
                &#34;consolidate&#34;: consolidate
            },
            include_summaries=include_summaries,
            requirements=requirements
        )
    
    def _format_interactions_report(self,
                                  interactions_data: List[Dict],
                                  title: str,
                                  include_summaries: bool,
                                  requirements: str) -&gt; str:
        &#34;&#34;&#34;Format interaction data into a Markdown report.&#34;&#34;&#34;
        # Prepare data for LLM formatting
        agents_data = []
        for data in interactions_data:
            agent_info = {
                &#34;name&#34;: data[&#34;agent&#34;].name,
                &#34;interactions&#34;: data[&#34;interactions&#34;]
            }
            if include_summaries:
                agent_info[&#34;bio&#34;] = data[&#34;agent&#34;].minibio(extended=False)
            agents_data.append(agent_info)
        
        # Generate report using LLM
        return self._generate_report_with_llm(
            title=title,
            report_type=&#34;interactions&#34;,
            data={&#34;agents_data&#34;: agents_data},
            include_summaries=include_summaries,
            requirements=requirements
        )
    
    def _format_data_report(self,
                          data: Any,
                          title: str,
                          requirements: str) -&gt; str:
        &#34;&#34;&#34;Format raw data into a Markdown report.&#34;&#34;&#34;
        return self._generate_report_with_llm(
            title=title,
            report_type=&#34;custom_data&#34;,
            data=data,
            requirements=requirements
        )

    
    def _generate_report_with_llm(self,
                                title: str,
                                report_type: str,
                                data: Any,
                                include_summaries: bool = False,
                                requirements: str = None) -&gt; str:
        &#34;&#34;&#34;Generate a report using LLM based on the report type and data.&#34;&#34;&#34;
        
        # Base system prompt
        system_prompt = &#34;You are a professional report writer who creates clear, well-structured Markdown reports.&#34;
        
        # Type-specific prompts and instructions
        if report_type == &#34;agent_interview&#34;:
            system_prompt += &#34; You specialize in synthesizing interview responses from multiple agents.&#34;
            user_prompt = f&#34;&#34;&#34;
            ## Task
            Create a comprehensive report based on agent interviews such that it fulfills the 
            specified requirements below.
            
            ## Report Title
            {title}
            
            ## Report Details
            - **Reporting Task:** {data[&#39;reporting_task&#39;]}
            - **Number of Agents Interviewed:** {len(data[&#39;agents_data&#39;])}
            - **Generated on:** {self._get_timestamp()}
            
            ## Agent Responses
            {json.dumps(data[&#39;agents_data&#39;], indent=2)}
            
            ## Instructions
            - Start with the title as a level-1 header
            - Write a direct, clear report, but do not simplify or summarize the information
            - Make sure all important details are included. This is not a summary, but a detailed report, so you never remove information, you just make it more readable
            - Do not include the original data or agent responses, but only the resulting report information
            - For each agent, include their bio if provided
            - Use proper Markdown formatting throughout
            - Follow the requirements given next, which can also override any of these rules
            
            ## Requirements
            {requirements}
            &#34;&#34;&#34;
            
        elif report_type == &#34;interactions&#34;:
            system_prompt += &#34; You specialize in analyzing and presenting agent interaction histories.&#34;
            user_prompt = f&#34;&#34;&#34;
            ## Task
            Create a report analyzing agent interactions from a simulation such that it fulfills the 
            specified requirements below.
            
            ## Report Title
            {title}
            
            ## Report Details
            - **Number of Agents Analyzed:** {len(data[&#39;agents_data&#39;])}
            - **Generated on:** {self._get_timestamp()}
            
            ## Agent Interaction Data
            {json.dumps(data[&#39;agents_data&#39;], indent=2)}
            
            ## Instructions
            - Start with the title as a level-1 header
            - Write a direct, clear report, but do not simplify or summarize the information
            - Make sure all important details are included. This is not a summary, but a detailed report, so you never remove information, you just make it more readable
            - Do not include agents&#39; interaction history, but only the resulting report information
            - For each agent, include their bio if provided
            - Use proper Markdown formatting throughout
            - Follow the requirements given next, which can also override any of these rules
            
            ## Requirements
            {requirements}
            &#34;&#34;&#34;
            
        elif report_type == &#34;custom_data&#34;:
            # Handle arbitrary data without assuming any structure
            if isinstance(data, str):
                data_representation = data
            else:
                # For any other type, convert to JSON for a clean representation
                data_representation = json.dumps(data, indent=2)
                
            user_prompt = f&#34;&#34;&#34;
            ## Task
            Create a well-structured Markdown report based on the provided data such that it fulfills the 
            specified requirements below.
            
            ## Report Title
            {title}
            
            ## Generated on
            {self._get_timestamp()}
            
            ## Data to Format
            {data_representation}
            
            ## Instructions
            - Start with the title as a level-1 header
            - Write a direct, clear report, but do not simplify or summarize the information
            - Make sure all important details are included. This is not a summary, but a detailed report, so you never remove information, you just make it more readable
            - Use proper Markdown formatting throughout
            - Follow the requirements given next, which can also override any of these rules
            
            ## Requirements
            {requirements if requirements else &#34;Use your best judgment to create a clear, informative report that presents the data in an organized and readable manner.&#34;}
            &#34;&#34;&#34;
        
        else:
            raise ValueError(f&#34;Unknown report type: {report_type}&#34;)
        
        # Generate the report
        report_chat = LLMChat(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            output_type=str,
            enable_json_output_format=False,
            model=default[&#34;model&#34;],
            temperature=0.3
        )
        
        return report_chat()
    
    
    def _get_timestamp(self) -&gt; str:
        &#34;&#34;&#34;Get current timestamp for report headers.&#34;&#34;&#34;
        from datetime import datetime
        return datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tinytroupe.extraction.results_reporter.ResultsReporter"><code class="flex name class">
<span>class <span class="ident">ResultsReporter</span></span>
<span>(</span><span>default_reporting_task: str = 'Summarize the key findings, insights, and outcomes from the simulation data.', verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the ResultsReporter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>default_reporting_task</code></strong> :&ensp;<code>str</code></dt>
<dd>The default task to ask agents when generating reports.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to print debug messages.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResultsReporter:
    
    def __init__(self, 
                 default_reporting_task: str = &#34;Summarize the key findings, insights, and outcomes from the simulation data.&#34;,
                 verbose: bool = False):
        &#34;&#34;&#34;
        Initializes the ResultsReporter.
        
        Args:
            default_reporting_task (str): The default task to ask agents when generating reports.
            verbose (bool): Whether to print debug messages.
        &#34;&#34;&#34;
        self.default_reporting_task = default_reporting_task
        self.verbose = verbose
        self.console = Console()
        
        # Cache for generated reports
        self.last_report = None
    
    def report_from_agents(self,
                          agents: Union[TinyPerson, TinyWorld, List[TinyPerson]],
                          reporting_task: str = None,
                          report_title: str = &#34;Simulation Report&#34;,
                          include_agent_summaries: bool = True,
                          consolidate_responses: bool = True,
                          requirements: str = &#34;Present the findings in a clear, structured manner.&#34;) -&gt; str:
        &#34;&#34;&#34;
        Option 1: Generate a report by asking agents about specific reporting tasks.
        
        Args:
            agents: Single agent, TinyWorld, or list of agents to interview.
            reporting_task: The specific task to ask agents about.
            report_title: Title for the generated report.
            include_agent_summaries: Whether to include agent mini-bios in the report.
            consolidate_responses: Whether to consolidate all responses into a single report.
            requirements: Formatting or content requirements for the report.
            
        Returns:
            str: The generated Markdown report.
        &#34;&#34;&#34;
        if reporting_task is None:
            reporting_task = self.default_reporting_task
            
        # Extract agents from input
        agent_list = self._extract_agents(agents)
        
        if self.verbose:
            logger.info(f&#34;Interviewing {len(agent_list)} agents for report generation.&#34;)
        
        # Collect responses from agents
        agent_responses = []
        for agent in agent_list:
            response = self._interview_agent(agent, reporting_task)
            agent_responses.append({
                &#34;agent&#34;: agent,
                &#34;response&#34;: response
            })
        
        # Generate the report
        report = self._format_agent_interview_report(
            agent_responses, 
            report_title, 
            reporting_task,
            include_agent_summaries,
            consolidate_responses,
            requirements
        )
        
        self.last_report = report
        return report
    
    def report_from_interactions(self,
                                agents: Union[TinyPerson, TinyWorld, List[TinyPerson]],
                                report_title: str = &#34;Interaction Analysis Report&#34;,
                                include_agent_summaries: bool = True,
                                first_n: int = None,
                                last_n: int = None,
                                max_content_length: int = None,
                                requirements: str = &#34;Present the findings in a clear, structured manner.&#34;) -&gt; str:
        &#34;&#34;&#34;
        Option 2: Generate a report by analyzing agents&#39; historical interactions.
        
        Args:
            agents: Single agent, TinyWorld, or list of agents to analyze.
            report_title: Title for the generated report.
            include_agent_summaries: Whether to include agent mini-bios.
            first_n: Number of first interactions to include.
            last_n: Number of last interactions to include.
            max_content_length: Maximum content length for interactions.
            requirements: Formatting or content requirements for the report.
            
        Returns:
            str: The generated Markdown report.
        &#34;&#34;&#34;
        # Extract agents from input
        agent_list = self._extract_agents(agents)
        
        if self.verbose:
            logger.info(f&#34;Analyzing interactions from {len(agent_list)} agents.&#34;)
        
        # Collect interaction data
        interactions_data = []
        for agent in agent_list:
            interactions = agent.pretty_current_interactions(
                simplified=True,
                first_n=first_n,
                last_n=last_n,
                max_content_length=max_content_length
            )
            interactions_data.append({
                &#34;agent&#34;: agent,
                &#34;interactions&#34;: interactions
            })
        
        # Generate the report
        report = self._format_interactions_report(
            interactions_data,
            report_title,
            include_agent_summaries,
            requirements
        )
        
        self.last_report = report
        return report
    
    def report_from_data(self,
                        data: Union[str, Dict[str, Any], List[Dict[str, Any]]],
                        report_title: str = &#34;Data Report&#34;,
                        requirements: str = &#34;Present the findings in a clear, structured manner.&#34;) -&gt; str:
        &#34;&#34;&#34;
        Option 3: Generate a report from raw text or structured data.
        
        Args:
            data: Raw text, dictionary, or list of dictionaries to format.
            report_title: Title for the generated report.
            requirements: Formatting or content requirements for the report. If None, uses simple formatting.
            
        Returns:
            str: The generated Markdown report.
        &#34;&#34;&#34;
        if self.verbose:
            logger.info(&#34;Generating report from raw data.&#34;)
        
        # Generate the report
        report = self._format_data_report(data, report_title, requirements)
        
        self.last_report = report
        return report
    
    def display_report(self, report: str = None):
        &#34;&#34;&#34;
        Display a report on the console with rich formatting.
        
        Args:
            report: The report to display. If None, uses the last generated report.
        &#34;&#34;&#34;
        if report is None:
            report = self.last_report
            
        if report is None:
            self.console.print(&#34;[red]No report available to display.[/red]&#34;)
            return
            
        markdown = Markdown(report)
        self.console.print(markdown)
    
    def save_report(self, 
                   filename: str,
                   report: str = None,
                   verbose: bool = None):
        &#34;&#34;&#34;
        Save a report to a file.
        
        Args:
            filename: The filename to save the report to.
            report: The report to save. If None, uses the last generated report.
            verbose: Whether to print confirmation message.
        &#34;&#34;&#34;
        if report is None:
            report = self.last_report
            
        if report is None:
            raise ValueError(&#34;No report available to save.&#34;)
            
        if verbose is None:
            verbose = self.verbose
            
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            f.write(report)
            
        if verbose:
            logger.info(f&#34;Report saved to {filename}&#34;)
    
    def _extract_agents(self, agents) -&gt; List[TinyPerson]:
        &#34;&#34;&#34;Extract a list of TinyPerson objects from various input types.&#34;&#34;&#34;
        if isinstance(agents, TinyPerson):
            return [agents]
        elif isinstance(agents, TinyWorld):
            return agents.agents
        elif isinstance(agents, list):
            return agents
        else:
            raise ValueError(&#34;Agents must be a TinyPerson, TinyWorld, or list of TinyPerson objects.&#34;)
    
    def _interview_agent(self, agent: TinyPerson, reporting_task: str) -&gt; str:
        &#34;&#34;&#34;Interview a single agent about the reporting task.&#34;&#34;&#34;
        if self.verbose:
            logger.debug(f&#34;Interviewing agent {agent.name} about: {reporting_task}&#34;)
        
        # Following TinyTroupe patterns - directly interact with the agent
        prompt = f&#34;&#34;&#34;
        I need you to provide a comprehensive report based on your experiences and observations.
        
        Reporting task: {reporting_task}
        
        Please provide detailed insights, specific examples, and key findings from your perspective.
        Focus on what you&#39;ve learned, observed, and experienced during the simulation.
        &#34;&#34;&#34;
        
        # Use listen_and_act pattern to get agent&#39;s response
        agent.listen(prompt)
        actions = agent.act(return_actions=True)
        
        # Extract the response from the agent&#39;s actions
        response = &#34;&#34;
        for action in actions:
            if action[&#34;action&#34;][&#34;type&#34;] == &#34;TALK&#34;:
                response += action[&#34;action&#34;][&#34;content&#34;] + &#34;\n&#34;
        
        if self.verbose:
            logger.debug(f&#34;Agent {agent.name} response received.&#34;)
        
        return response.strip()
    
    def _format_agent_interview_report(self, 
                                     agent_responses: List[Dict],
                                     title: str,
                                     task: str,
                                     include_summaries: bool,
                                     consolidate: bool,
                                     requirements: str) -&gt; str:
        &#34;&#34;&#34;Format agent interview responses into a Markdown report.&#34;&#34;&#34;
        # Prepare data for LLM formatting
        agents_data = []
        for resp in agent_responses:
            agent_info = {
                &#34;name&#34;: resp[&#34;agent&#34;].name,
                &#34;response&#34;: resp[&#34;response&#34;]
            }
            if include_summaries:
                agent_info[&#34;bio&#34;] = resp[&#34;agent&#34;].minibio(extended=False)
            agents_data.append(agent_info)
        
        # Generate report using LLM
        return self._generate_report_with_llm(
            title=title,
            report_type=&#34;agent_interview&#34;,
            data={
                &#34;reporting_task&#34;: task,
                &#34;agents_data&#34;: agents_data,
                &#34;consolidate&#34;: consolidate
            },
            include_summaries=include_summaries,
            requirements=requirements
        )
    
    def _format_interactions_report(self,
                                  interactions_data: List[Dict],
                                  title: str,
                                  include_summaries: bool,
                                  requirements: str) -&gt; str:
        &#34;&#34;&#34;Format interaction data into a Markdown report.&#34;&#34;&#34;
        # Prepare data for LLM formatting
        agents_data = []
        for data in interactions_data:
            agent_info = {
                &#34;name&#34;: data[&#34;agent&#34;].name,
                &#34;interactions&#34;: data[&#34;interactions&#34;]
            }
            if include_summaries:
                agent_info[&#34;bio&#34;] = data[&#34;agent&#34;].minibio(extended=False)
            agents_data.append(agent_info)
        
        # Generate report using LLM
        return self._generate_report_with_llm(
            title=title,
            report_type=&#34;interactions&#34;,
            data={&#34;agents_data&#34;: agents_data},
            include_summaries=include_summaries,
            requirements=requirements
        )
    
    def _format_data_report(self,
                          data: Any,
                          title: str,
                          requirements: str) -&gt; str:
        &#34;&#34;&#34;Format raw data into a Markdown report.&#34;&#34;&#34;
        return self._generate_report_with_llm(
            title=title,
            report_type=&#34;custom_data&#34;,
            data=data,
            requirements=requirements
        )

    
    def _generate_report_with_llm(self,
                                title: str,
                                report_type: str,
                                data: Any,
                                include_summaries: bool = False,
                                requirements: str = None) -&gt; str:
        &#34;&#34;&#34;Generate a report using LLM based on the report type and data.&#34;&#34;&#34;
        
        # Base system prompt
        system_prompt = &#34;You are a professional report writer who creates clear, well-structured Markdown reports.&#34;
        
        # Type-specific prompts and instructions
        if report_type == &#34;agent_interview&#34;:
            system_prompt += &#34; You specialize in synthesizing interview responses from multiple agents.&#34;
            user_prompt = f&#34;&#34;&#34;
            ## Task
            Create a comprehensive report based on agent interviews such that it fulfills the 
            specified requirements below.
            
            ## Report Title
            {title}
            
            ## Report Details
            - **Reporting Task:** {data[&#39;reporting_task&#39;]}
            - **Number of Agents Interviewed:** {len(data[&#39;agents_data&#39;])}
            - **Generated on:** {self._get_timestamp()}
            
            ## Agent Responses
            {json.dumps(data[&#39;agents_data&#39;], indent=2)}
            
            ## Instructions
            - Start with the title as a level-1 header
            - Write a direct, clear report, but do not simplify or summarize the information
            - Make sure all important details are included. This is not a summary, but a detailed report, so you never remove information, you just make it more readable
            - Do not include the original data or agent responses, but only the resulting report information
            - For each agent, include their bio if provided
            - Use proper Markdown formatting throughout
            - Follow the requirements given next, which can also override any of these rules
            
            ## Requirements
            {requirements}
            &#34;&#34;&#34;
            
        elif report_type == &#34;interactions&#34;:
            system_prompt += &#34; You specialize in analyzing and presenting agent interaction histories.&#34;
            user_prompt = f&#34;&#34;&#34;
            ## Task
            Create a report analyzing agent interactions from a simulation such that it fulfills the 
            specified requirements below.
            
            ## Report Title
            {title}
            
            ## Report Details
            - **Number of Agents Analyzed:** {len(data[&#39;agents_data&#39;])}
            - **Generated on:** {self._get_timestamp()}
            
            ## Agent Interaction Data
            {json.dumps(data[&#39;agents_data&#39;], indent=2)}
            
            ## Instructions
            - Start with the title as a level-1 header
            - Write a direct, clear report, but do not simplify or summarize the information
            - Make sure all important details are included. This is not a summary, but a detailed report, so you never remove information, you just make it more readable
            - Do not include agents&#39; interaction history, but only the resulting report information
            - For each agent, include their bio if provided
            - Use proper Markdown formatting throughout
            - Follow the requirements given next, which can also override any of these rules
            
            ## Requirements
            {requirements}
            &#34;&#34;&#34;
            
        elif report_type == &#34;custom_data&#34;:
            # Handle arbitrary data without assuming any structure
            if isinstance(data, str):
                data_representation = data
            else:
                # For any other type, convert to JSON for a clean representation
                data_representation = json.dumps(data, indent=2)
                
            user_prompt = f&#34;&#34;&#34;
            ## Task
            Create a well-structured Markdown report based on the provided data such that it fulfills the 
            specified requirements below.
            
            ## Report Title
            {title}
            
            ## Generated on
            {self._get_timestamp()}
            
            ## Data to Format
            {data_representation}
            
            ## Instructions
            - Start with the title as a level-1 header
            - Write a direct, clear report, but do not simplify or summarize the information
            - Make sure all important details are included. This is not a summary, but a detailed report, so you never remove information, you just make it more readable
            - Use proper Markdown formatting throughout
            - Follow the requirements given next, which can also override any of these rules
            
            ## Requirements
            {requirements if requirements else &#34;Use your best judgment to create a clear, informative report that presents the data in an organized and readable manner.&#34;}
            &#34;&#34;&#34;
        
        else:
            raise ValueError(f&#34;Unknown report type: {report_type}&#34;)
        
        # Generate the report
        report_chat = LLMChat(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            output_type=str,
            enable_json_output_format=False,
            model=default[&#34;model&#34;],
            temperature=0.3
        )
        
        return report_chat()
    
    
    def _get_timestamp(self) -&gt; str:
        &#34;&#34;&#34;Get current timestamp for report headers.&#34;&#34;&#34;
        from datetime import datetime
        return datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tinytroupe.extraction.results_reporter.ResultsReporter.display_report"><code class="name flex">
<span>def <span class="ident">display_report</span></span>(<span>self, report: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Display a report on the console with rich formatting.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>report</code></strong></dt>
<dd>The report to display. If None, uses the last generated report.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_report(self, report: str = None):
    &#34;&#34;&#34;
    Display a report on the console with rich formatting.
    
    Args:
        report: The report to display. If None, uses the last generated report.
    &#34;&#34;&#34;
    if report is None:
        report = self.last_report
        
    if report is None:
        self.console.print(&#34;[red]No report available to display.[/red]&#34;)
        return
        
    markdown = Markdown(report)
    self.console.print(markdown)</code></pre>
</details>
</dd>
<dt id="tinytroupe.extraction.results_reporter.ResultsReporter.report_from_agents"><code class="name flex">
<span>def <span class="ident">report_from_agents</span></span>(<span>self, agents: Union[<a title="tinytroupe.agent.tiny_person.TinyPerson" href="../agent/tiny_person.html#tinytroupe.agent.tiny_person.TinyPerson">TinyPerson</a>, <a title="tinytroupe.environment.tiny_world.TinyWorld" href="../environment/tiny_world.html#tinytroupe.environment.tiny_world.TinyWorld">TinyWorld</a>, List[<a title="tinytroupe.agent.tiny_person.TinyPerson" href="../agent/tiny_person.html#tinytroupe.agent.tiny_person.TinyPerson">TinyPerson</a>]], reporting_task: str = None, report_title: str = 'Simulation Report', include_agent_summaries: bool = True, consolidate_responses: bool = True, requirements: str = 'Present the findings in a clear, structured manner.') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Option 1: Generate a report by asking agents about specific reporting tasks.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>agents</code></strong></dt>
<dd>Single agent, TinyWorld, or list of agents to interview.</dd>
<dt><strong><code>reporting_task</code></strong></dt>
<dd>The specific task to ask agents about.</dd>
<dt><strong><code>report_title</code></strong></dt>
<dd>Title for the generated report.</dd>
<dt><strong><code>include_agent_summaries</code></strong></dt>
<dd>Whether to include agent mini-bios in the report.</dd>
<dt><strong><code>consolidate_responses</code></strong></dt>
<dd>Whether to consolidate all responses into a single report.</dd>
<dt><strong><code>requirements</code></strong></dt>
<dd>Formatting or content requirements for the report.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated Markdown report.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_from_agents(self,
                      agents: Union[TinyPerson, TinyWorld, List[TinyPerson]],
                      reporting_task: str = None,
                      report_title: str = &#34;Simulation Report&#34;,
                      include_agent_summaries: bool = True,
                      consolidate_responses: bool = True,
                      requirements: str = &#34;Present the findings in a clear, structured manner.&#34;) -&gt; str:
    &#34;&#34;&#34;
    Option 1: Generate a report by asking agents about specific reporting tasks.
    
    Args:
        agents: Single agent, TinyWorld, or list of agents to interview.
        reporting_task: The specific task to ask agents about.
        report_title: Title for the generated report.
        include_agent_summaries: Whether to include agent mini-bios in the report.
        consolidate_responses: Whether to consolidate all responses into a single report.
        requirements: Formatting or content requirements for the report.
        
    Returns:
        str: The generated Markdown report.
    &#34;&#34;&#34;
    if reporting_task is None:
        reporting_task = self.default_reporting_task
        
    # Extract agents from input
    agent_list = self._extract_agents(agents)
    
    if self.verbose:
        logger.info(f&#34;Interviewing {len(agent_list)} agents for report generation.&#34;)
    
    # Collect responses from agents
    agent_responses = []
    for agent in agent_list:
        response = self._interview_agent(agent, reporting_task)
        agent_responses.append({
            &#34;agent&#34;: agent,
            &#34;response&#34;: response
        })
    
    # Generate the report
    report = self._format_agent_interview_report(
        agent_responses, 
        report_title, 
        reporting_task,
        include_agent_summaries,
        consolidate_responses,
        requirements
    )
    
    self.last_report = report
    return report</code></pre>
</details>
</dd>
<dt id="tinytroupe.extraction.results_reporter.ResultsReporter.report_from_data"><code class="name flex">
<span>def <span class="ident">report_from_data</span></span>(<span>self, data: Union[str, Dict[str, Any], List[Dict[str, Any]]], report_title: str = 'Data Report', requirements: str = 'Present the findings in a clear, structured manner.') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Option 3: Generate a report from raw text or structured data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Raw text, dictionary, or list of dictionaries to format.</dd>
<dt><strong><code>report_title</code></strong></dt>
<dd>Title for the generated report.</dd>
<dt><strong><code>requirements</code></strong></dt>
<dd>Formatting or content requirements for the report. If None, uses simple formatting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated Markdown report.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_from_data(self,
                    data: Union[str, Dict[str, Any], List[Dict[str, Any]]],
                    report_title: str = &#34;Data Report&#34;,
                    requirements: str = &#34;Present the findings in a clear, structured manner.&#34;) -&gt; str:
    &#34;&#34;&#34;
    Option 3: Generate a report from raw text or structured data.
    
    Args:
        data: Raw text, dictionary, or list of dictionaries to format.
        report_title: Title for the generated report.
        requirements: Formatting or content requirements for the report. If None, uses simple formatting.
        
    Returns:
        str: The generated Markdown report.
    &#34;&#34;&#34;
    if self.verbose:
        logger.info(&#34;Generating report from raw data.&#34;)
    
    # Generate the report
    report = self._format_data_report(data, report_title, requirements)
    
    self.last_report = report
    return report</code></pre>
</details>
</dd>
<dt id="tinytroupe.extraction.results_reporter.ResultsReporter.report_from_interactions"><code class="name flex">
<span>def <span class="ident">report_from_interactions</span></span>(<span>self, agents: Union[<a title="tinytroupe.agent.tiny_person.TinyPerson" href="../agent/tiny_person.html#tinytroupe.agent.tiny_person.TinyPerson">TinyPerson</a>, <a title="tinytroupe.environment.tiny_world.TinyWorld" href="../environment/tiny_world.html#tinytroupe.environment.tiny_world.TinyWorld">TinyWorld</a>, List[<a title="tinytroupe.agent.tiny_person.TinyPerson" href="../agent/tiny_person.html#tinytroupe.agent.tiny_person.TinyPerson">TinyPerson</a>]], report_title: str = 'Interaction Analysis Report', include_agent_summaries: bool = True, first_n: int = None, last_n: int = None, max_content_length: int = None, requirements: str = 'Present the findings in a clear, structured manner.') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Option 2: Generate a report by analyzing agents' historical interactions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>agents</code></strong></dt>
<dd>Single agent, TinyWorld, or list of agents to analyze.</dd>
<dt><strong><code>report_title</code></strong></dt>
<dd>Title for the generated report.</dd>
<dt><strong><code>include_agent_summaries</code></strong></dt>
<dd>Whether to include agent mini-bios.</dd>
<dt><strong><code>first_n</code></strong></dt>
<dd>Number of first interactions to include.</dd>
<dt><strong><code>last_n</code></strong></dt>
<dd>Number of last interactions to include.</dd>
<dt><strong><code>max_content_length</code></strong></dt>
<dd>Maximum content length for interactions.</dd>
<dt><strong><code>requirements</code></strong></dt>
<dd>Formatting or content requirements for the report.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated Markdown report.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_from_interactions(self,
                            agents: Union[TinyPerson, TinyWorld, List[TinyPerson]],
                            report_title: str = &#34;Interaction Analysis Report&#34;,
                            include_agent_summaries: bool = True,
                            first_n: int = None,
                            last_n: int = None,
                            max_content_length: int = None,
                            requirements: str = &#34;Present the findings in a clear, structured manner.&#34;) -&gt; str:
    &#34;&#34;&#34;
    Option 2: Generate a report by analyzing agents&#39; historical interactions.
    
    Args:
        agents: Single agent, TinyWorld, or list of agents to analyze.
        report_title: Title for the generated report.
        include_agent_summaries: Whether to include agent mini-bios.
        first_n: Number of first interactions to include.
        last_n: Number of last interactions to include.
        max_content_length: Maximum content length for interactions.
        requirements: Formatting or content requirements for the report.
        
    Returns:
        str: The generated Markdown report.
    &#34;&#34;&#34;
    # Extract agents from input
    agent_list = self._extract_agents(agents)
    
    if self.verbose:
        logger.info(f&#34;Analyzing interactions from {len(agent_list)} agents.&#34;)
    
    # Collect interaction data
    interactions_data = []
    for agent in agent_list:
        interactions = agent.pretty_current_interactions(
            simplified=True,
            first_n=first_n,
            last_n=last_n,
            max_content_length=max_content_length
        )
        interactions_data.append({
            &#34;agent&#34;: agent,
            &#34;interactions&#34;: interactions
        })
    
    # Generate the report
    report = self._format_interactions_report(
        interactions_data,
        report_title,
        include_agent_summaries,
        requirements
    )
    
    self.last_report = report
    return report</code></pre>
</details>
</dd>
<dt id="tinytroupe.extraction.results_reporter.ResultsReporter.save_report"><code class="name flex">
<span>def <span class="ident">save_report</span></span>(<span>self, filename: str, report: str = None, verbose: bool = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save a report to a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>The filename to save the report to.</dd>
<dt><strong><code>report</code></strong></dt>
<dd>The report to save. If None, uses the last generated report.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>Whether to print confirmation message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_report(self, 
               filename: str,
               report: str = None,
               verbose: bool = None):
    &#34;&#34;&#34;
    Save a report to a file.
    
    Args:
        filename: The filename to save the report to.
        report: The report to save. If None, uses the last generated report.
        verbose: Whether to print confirmation message.
    &#34;&#34;&#34;
    if report is None:
        report = self.last_report
        
    if report is None:
        raise ValueError(&#34;No report available to save.&#34;)
        
    if verbose is None:
        verbose = self.verbose
        
    with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
        f.write(report)
        
    if verbose:
        logger.info(f&#34;Report saved to {filename}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tinytroupe.extraction" href="index.html">tinytroupe.extraction</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tinytroupe.extraction.results_reporter.ResultsReporter" href="#tinytroupe.extraction.results_reporter.ResultsReporter">ResultsReporter</a></code></h4>
<ul class="">
<li><code><a title="tinytroupe.extraction.results_reporter.ResultsReporter.display_report" href="#tinytroupe.extraction.results_reporter.ResultsReporter.display_report">display_report</a></code></li>
<li><code><a title="tinytroupe.extraction.results_reporter.ResultsReporter.report_from_agents" href="#tinytroupe.extraction.results_reporter.ResultsReporter.report_from_agents">report_from_agents</a></code></li>
<li><code><a title="tinytroupe.extraction.results_reporter.ResultsReporter.report_from_data" href="#tinytroupe.extraction.results_reporter.ResultsReporter.report_from_data">report_from_data</a></code></li>
<li><code><a title="tinytroupe.extraction.results_reporter.ResultsReporter.report_from_interactions" href="#tinytroupe.extraction.results_reporter.ResultsReporter.report_from_interactions">report_from_interactions</a></code></li>
<li><code><a title="tinytroupe.extraction.results_reporter.ResultsReporter.save_report" href="#tinytroupe.extraction.results_reporter.ResultsReporter.save_report">save_report</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>